<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>iOS俄罗斯方块</title>
    <style>
    /* 全局重置 */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
    }

    body {
        background: #f0f0f0;
        overflow: hidden;
        position: fixed;
        width: 100%;
        height: 100%;
    }

    /* 游戏容器 */
    .game-container {
        position: relative;
        max-width: 375px;
        margin: 0 auto;
        height: 100vh;
        padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    /* 画布区域 */
    #gameCanvas {
        display: block;
        margin: 20px auto 0;
        background: #000;
        border: 2px solid #333;
        image-rendering: pixelated;
        touch-action: none;
    }

    /* 得分显示 */
    .score {
        text-align: center;
        font: 18px/1.5 -apple-system, Arial;
        color: #333;
        padding-top: max(10px, env(safe-area-inset-top));
    }

    /* 控制按钮 */
    .controls {
        position: fixed;
        bottom: calc(20px + env(safe-area-inset-bottom));
        left: 50%;
        transform: translateX(-50%);
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 12px;
        padding: 0 15px;
        width: 100%;
        max-width: 375px;
    }

    .btn {
        width: 58px;
        height: 58px;
        background: #4CAF50;
        border: none;
        border-radius: 29px;
        color: white;
        font: 22px/58px -apple-system, Arial;
        text-align: center;
        touch-action: manipulation;
    }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="score">得分: <span id="score">0</span></div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <button class="btn" id="leftBtn">←</button>
            <button class="btn" id="dropBtn">↓</button>
            <button class="btn" id="rotateBtn">↻</button>
            <button class="btn" id="rightBtn">→</button>
        </div>
    </div>

<script>
(function() {
    // iOS弹性滚动处理
    let touchStartY = 0;
    const handleTouchStart = (e) => {
        touchStartY = e.touches[0].clientY;
    };
    const handleTouchMove = (e) => {
        if (Math.abs(e.touches[0].clientY - touchStartY) > 5) {
            e.preventDefault();
        }
    };
    document.addEventListener('touchstart', handleTouchStart, { passive: false });
    document.addEventListener('touchmove', handleTouchMove, { passive: false });

    // 游戏初始化
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const BLOCK_SIZE = 28;  // iOS优化尺寸
    const COLS = 10, ROWS = 20;
    
    // 设置画布尺寸
    const initCanvas = () => {
        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;
    };
    initCanvas();

    // 游戏配置
    const SHAPES = [
        [[1,1,1,1]], [[1,1,1],[0,1,0]], [[1,1,1],[1,0,0]],
        [[1,1,1],[0,0,1]], [[1,1],[1,1]], [[1,1,0],[0,1,1]],
        [[0,1,1],[1,1,0]]
    ];
    const COLORS = ['#00f0f0','#f0a000','#0000f0','#f0f000','#a0a0a0','#00f000','#f00000'];
    
    let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let currentPiece = null;
    let currentX = 0, currentY = 0, score = 0;

    // 游戏功能函数
    const createPiece = () => {
        const type = Math.floor(Math.random() * SHAPES.length);
        return { shape: SHAPES[type], color: COLORS[type] };
    };

    const drawBoard = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        board.forEach((row, y) => {
            row.forEach((color, x) => {
                if(color) {
                    ctx.fillStyle = color;
                    ctx.fillRect(x*BLOCK_SIZE, y*BLOCK_SIZE, BLOCK_SIZE-1, BLOCK_SIZE-1);
                }
            });
        });
    };

    const drawPiece = () => {
        ctx.fillStyle = currentPiece.color;
        currentPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if(value) {
                    ctx.fillRect(
                        (currentX + x)*BLOCK_SIZE,
                        (currentY + y)*BLOCK_SIZE,
                        BLOCK_SIZE-1,
                        BLOCK_SIZE-1
                    );
                }
            });
        });
    };

    const canMove = (piece, newX, newY) => {
        return piece.shape.every((row, dy) => 
            row.every((value, dx) => {
                const x = newX + dx;
                const y = newY + dy;
                return !value || (x >= 0 && x < COLS && y < ROWS && !board[y][x]);
            })
        );
    };

    const mergePiece = () => {
        currentPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if(value) board[currentY+y][currentX+x] = currentPiece.color;
            });
        });
    };

    const rotate = () => {
        const newShape = currentPiece.shape[0].map((_, i) =>
            currentPiece.shape.map(row => row[i]).reverse()
        );
        if(canMove({ shape: newShape }, currentX, currentY)) {
            currentPiece.shape = newShape;
        }
    };

    const clearLines = () => {
        let lines = 0;
        for(let y = ROWS-1; y >= 0; y--) {
            if(board[y].every(cell => cell)) {
                board.splice(y, 1);
                board.unshift(Array(COLS).fill(0));
                lines++;
                y++;
            }
        }
        if(lines) {
            score += lines * 100;
            document.getElementById('score').textContent = score;
        }
    };

    // 硬降功能
    const hardDrop = () => {
        while(canMove(currentPiece, currentX, currentY + 1)) currentY++;
        mergePiece();
        clearLines();
        newPiece();
    };

    const newPiece = () => {
        currentPiece = createPiece();
        currentX = Math.floor(COLS/2 - currentPiece.shape[0].length/2);
        currentY = 0;
        if(!canMove(currentPiece, currentX, currentY)) {
            alert(`游戏结束！得分：${score}`);
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            score = 0;
            document.getElementById('score').textContent = score;
        }
    };

    // 游戏循环
    let lastTime = 0;
    const gameLoop = (timestamp) => {
        if(timestamp - lastTime > 1000) {
            if(canMove(currentPiece, currentX, currentY+1)) {
                currentY++;
            } else {
                mergePiece();
                clearLines();
                newPiece();
            }
            drawBoard();
            drawPiece();
            lastTime = timestamp;
        }
        requestAnimationFrame(gameLoop);
    };

    // 事件绑定
    document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if(canMove(currentPiece, currentX-1, currentY)) currentX--;
    });
    document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if(canMove(currentPiece, currentX+1, currentY)) currentX++;
    });
    document.getElementById('rotateBtn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        rotate();
    });
    document.getElementById('dropBtn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        hardDrop();
    });

    // 启动游戏
    newPiece();
    requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>